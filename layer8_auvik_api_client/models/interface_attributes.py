# coding: utf-8

"""
Auvik API

To use the Auvik APIs, you’ll need a <a href=\"https://support.auvik.com/hc/en-us/articles/204309114-#topic_generate\" target=\"_blank\">valid Auvik user and the user’s API key</a>. The user must also have the correct <a href=\" https://support.auvik.com/hc/en-us/articles/115002815966\" target=\"_blank\">role permissions</a>.<br>     <br>     Note: The word <i>tenant</i> as it appears in the API descriptions means one of Auvik’s supported tenant types: multi-client or client.<br><br>All date formats are formatted in the format of YYYY-MM-DDTHH:MM:SS.sssZ, as describe in ISO 8061<br><br>To find out more about Auvik’s APIs, <a href=\"https://support.auvik.com/hc/en-us/articles/360017965092\" target=\"_blank\">click here.</a>

The version of the OpenAPI document: v1
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import List, Optional
from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist, validator


class InterfaceAttributes(BaseModel):
    """
    The type-specific properties of the interfaces object returned  # noqa: E501
    """

    interface_name: StrictStr = Field(
        ..., alias="interfaceName", description="This interface's name"
    )
    interface_type: StrictStr = Field(
        ..., alias="interfaceType", description="This interface's type"
    )
    mac_address: Optional[StrictStr] = Field(
        ..., alias="macAddress", description="MAC address"
    )
    negotiated_speed: Optional[StrictStr] = Field(
        ..., alias="negotiatedSpeed", description="Negotiated speed"
    )
    duplex: StrictStr = Field(..., description="Duplex mode of this interface")
    custom_connections: StrictBool = Field(
        ...,
        alias="customConnections",
        description="Whether this interface allows custom connections",
    )
    ip_addresses: conlist(StrictStr) = Field(
        ..., alias="ipAddresses", description="This interface's IP addresses"
    )
    operational_status: StrictStr = Field(
        ...,
        alias="operationalStatus",
        description="This interface's operational status",
    )
    admin_status: StrictBool = Field(
        ..., alias="adminStatus", description="Whether this interface is enabled"
    )
    last_modified: StrictStr = Field(
        ...,
        alias="lastModified",
        description="When one of this interface's attributes was last modified",
    )
    __properties = [
        "interfaceName",
        "interfaceType",
        "macAddress",
        "negotiatedSpeed",
        "duplex",
        "customConnections",
        "ipAddresses",
        "operationalStatus",
        "adminStatus",
        "lastModified",
    ]

    @validator("interface_type")
    def interface_type_validate_enum(cls, value):
        """Validates the enum"""
        if value not in (
            "ethernet",
            "wifi",
            "bluetooth",
            "cdma",
            "coax",
            "cpu",
            "distributedVirtualSwitch",
            "firewire",
            "gsm",
            "ieee8023AdLag",
            "inferredWired",
            "inferredWireless",
            "interface",
            "linkAggregation",
            "loopback",
            "modem",
            "wimax",
            "optical",
            "other",
            "parallel",
            "ppp",
            "radiomac",
            "rs232",
            "tunnel",
            "unknown",
            "usb",
            "virtualBridge",
            "virtualNic",
            "virtualSwitch",
            "vlan",
        ):
            raise ValueError(
                "must be one of enum values ('ethernet', 'wifi', 'bluetooth', 'cdma', 'coax', 'cpu', 'distributedVirtualSwitch', 'firewire', 'gsm', 'ieee8023AdLag', 'inferredWired', 'inferredWireless', 'interface', 'linkAggregation', 'loopback', 'modem', 'wimax', 'optical', 'other', 'parallel', 'ppp', 'radiomac', 'rs232', 'tunnel', 'unknown', 'usb', 'virtualBridge', 'virtualNic', 'virtualSwitch', 'vlan')"
            )
        return value

    @validator("duplex")
    def duplex_validate_enum(cls, value):
        """Validates the enum"""
        if value not in ("unknown", "half", "full"):
            raise ValueError("must be one of enum values ('unknown', 'half', 'full')")
        return value

    @validator("operational_status")
    def operational_status_validate_enum(cls, value):
        """Validates the enum"""
        if value not in (
            "online",
            "offline",
            "unreachable",
            "testing",
            "unknown",
            "dormant",
            "notPresent",
            "lowerLayerDown",
        ):
            raise ValueError(
                "must be one of enum values ('online', 'offline', 'unreachable', 'testing', 'unknown', 'dormant', 'notPresent', 'lowerLayerDown')"
            )
        return value

    class Config:
        """Pydantic configuration"""

        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> InterfaceAttributes:
        """Create an instance of InterfaceAttributes from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
        # set to None if make_model (nullable) is None
        # and __fields_set__ contains the field
        if self.mac_address is None and "mac_address" in self.__fields_set__:
            _dict["macAddress"] = None
        if self.negotiated_speed is None and "negotiated_speed" in self.__fields_set__:
            _dict["negotiatedSpeed"] = None
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> InterfaceAttributes:
        """Create an instance of InterfaceAttributes from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return InterfaceAttributes.parse_obj(obj)

        _obj = InterfaceAttributes.parse_obj(
            {
                "interface_name": obj.get("interfaceName"),
                "interface_type": obj.get("interfaceType"),
                "mac_address": obj.get("macAddress"),
                "negotiated_speed": obj.get("negotiatedSpeed"),
                "duplex": obj.get("duplex"),
                "custom_connections": obj.get("customConnections"),
                "ip_addresses": obj.get("ipAddresses"),
                "operational_status": obj.get("operationalStatus"),
                "admin_status": obj.get("adminStatus"),
                "last_modified": obj.get("lastModified"),
            }
        )
        return _obj
