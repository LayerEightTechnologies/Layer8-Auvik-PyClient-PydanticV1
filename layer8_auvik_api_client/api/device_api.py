# coding: utf-8

"""
    Auvik API

    To use the Auvik APIs, you’ll need a <a href=\"https://support.auvik.com/hc/en-us/articles/204309114-#topic_generate\" target=\"_blank\">valid Auvik user and the user’s API key</a>. The user must also have the correct <a href=\" https://support.auvik.com/hc/en-us/articles/115002815966\" target=\"_blank\">role permissions</a>.<br>     <br>     Note: The word <i>tenant</i> as it appears in the API descriptions means one of Auvik’s supported tenant types: multi-client or client.<br><br>All date formats are formatted in the format of YYYY-MM-DDTHH:MM:SS.sssZ, as describe in ISO 8061<br><br>To find out more about Auvik’s APIs, <a href=\"https://support.auvik.com/hc/en-us/articles/360017965092\" target=\"_blank\">click here.</a>

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import re  # noqa: F401
import io
import warnings

from pydantic import validate_arguments, ValidationError

from typing_extensions import Annotated
from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr

from typing import Optional, Union

from layer8_auvik_api_client.models.device_details_extended_read_multiple import DeviceDetailsExtendedReadMultiple
from layer8_auvik_api_client.models.device_details_extended_read_single import DeviceDetailsExtendedReadSingle
from layer8_auvik_api_client.models.device_details_read_multiple import DeviceDetailsReadMultiple
from layer8_auvik_api_client.models.device_details_read_single import DeviceDetailsReadSingle
from layer8_auvik_api_client.models.device_info_read_multiple import DeviceInfoReadMultiple
from layer8_auvik_api_client.models.device_info_read_single import DeviceInfoReadSingle
from layer8_auvik_api_client.models.device_lifecycle_read_multiple import DeviceLifecycleReadMultiple
from layer8_auvik_api_client.models.device_lifecycle_read_single import DeviceLifecycleReadSingle
from layer8_auvik_api_client.models.device_type_schema import DeviceTypeSchema
from layer8_auvik_api_client.models.device_warranty_read_multiple import DeviceWarrantyReadMultiple
from layer8_auvik_api_client.models.device_warranty_read_single import DeviceWarrantyReadSingle

from layer8_auvik_api_client.api_client import ApiClient
from layer8_auvik_api_client.api_response import ApiResponse
from layer8_auvik_api_client.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class DeviceApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def read_multiple_device_details(self, filter_manage_status : Annotated[Optional[StrictBool], Field(description="Filter by managed status")] = None, filter_discovery_snmp : Annotated[Optional[StrictStr], Field(description="Filter by the device’s SNMP discovery status.")] = None, filter_discovery_wmi : Annotated[Optional[StrictStr], Field(description="Filter by the device’s WMI discovery status.")] = None, filter_discovery_login : Annotated[Optional[StrictStr], Field(description="Filter by the device’s Login discovery status.")] = None, filter_discovery_v_mware : Annotated[Optional[StrictStr], Field(description="Filter by the device’s VMware discovery status.")] = None, filter_traffic_insights_status : Annotated[Optional[StrictStr], Field(description="Filter by the device’s TrafficInsights status.")] = None, tenants : Annotated[Optional[StrictStr], Field(description="Comma delimited list of tenant IDs to request info from.")] = None, page_first : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="For paginated responses, the first N elements will be returned. Used in combination with <code>page[after]</code>.")] = None, page_after : Annotated[Optional[StrictStr], Field(description="Cursor after which elements will be returned as a page. The page size is provided by <code>page[first]</code>.")] = None, page_last : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="For paginated responses, the last N services will be returned. Used in combination with <code>page[before]</code>.")] = None, page_before : Annotated[Optional[StrictStr], Field(description="Cursor before which elements will be returned as a page. The page size is provided by <code>page[last]</code>.")] = None, **kwargs) -> DeviceDetailsReadMultiple:  # noqa: E501
        """Read Multiple Devices’ Details  # noqa: E501

        Use the Read Multiple Devices’ Details API to pull extra collected information about the various devices Auvik has discovered not already included in the Device Info API. You’ll need the client IDs for the clients you want to run the multiple read against.<br> <br> To find the client IDs, run the <a href=\"#operation/readMultipleTenants\">Read Multiple Tenants API.</a><br> <br> Looking at the detail screen on the right, click cURL to see the command that will be used. Click <b>Copy</b> to copy the details of the command to your clipboard. Be sure to edit the following parameters within the command: <ul>     <li>Within the API URL, <b>us1.my</b> (https://auvikapi.us1.my.auvik.com) should be updated to match the region in which your account resides. To locate the region, log into your Auvik dashboard and look at the URL in your browser’s address bar.</li>     <li><i>user@example.com</i> should be the email address of a user with permissions to view device details.</li>     <li><i>apiKey</i> should be the API key that’s been set for the user.</li>     <li><i>195798545063742726</i> should be the ID or comma delimited IDs of the client(s) whose data you wish to fetch information from. </li>     <li><i>filter[deviceType]=router</i> should be whichever key and value pair you want to filter the result set by. See below for a list of filterable parameters.</li> </ul>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.read_multiple_device_details(filter_manage_status, filter_discovery_snmp, filter_discovery_wmi, filter_discovery_login, filter_discovery_v_mware, filter_traffic_insights_status, tenants, page_first, page_after, page_last, page_before, async_req=True)
        >>> result = thread.get()

        :param filter_manage_status: Filter by managed status
        :type filter_manage_status: bool
        :param filter_discovery_snmp: Filter by the device’s SNMP discovery status.
        :type filter_discovery_snmp: str
        :param filter_discovery_wmi: Filter by the device’s WMI discovery status.
        :type filter_discovery_wmi: str
        :param filter_discovery_login: Filter by the device’s Login discovery status.
        :type filter_discovery_login: str
        :param filter_discovery_v_mware: Filter by the device’s VMware discovery status.
        :type filter_discovery_v_mware: str
        :param filter_traffic_insights_status: Filter by the device’s TrafficInsights status.
        :type filter_traffic_insights_status: str
        :param tenants: Comma delimited list of tenant IDs to request info from.
        :type tenants: str
        :param page_first: For paginated responses, the first N elements will be returned. Used in combination with <code>page[after]</code>.
        :type page_first: float
        :param page_after: Cursor after which elements will be returned as a page. The page size is provided by <code>page[first]</code>.
        :type page_after: str
        :param page_last: For paginated responses, the last N services will be returned. Used in combination with <code>page[before]</code>.
        :type page_last: float
        :param page_before: Cursor before which elements will be returned as a page. The page size is provided by <code>page[last]</code>.
        :type page_before: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DeviceDetailsReadMultiple
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the read_multiple_device_details_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.read_multiple_device_details_with_http_info(filter_manage_status, filter_discovery_snmp, filter_discovery_wmi, filter_discovery_login, filter_discovery_v_mware, filter_traffic_insights_status, tenants, page_first, page_after, page_last, page_before, **kwargs)  # noqa: E501

    @validate_arguments
    def read_multiple_device_details_with_http_info(self, filter_manage_status : Annotated[Optional[StrictBool], Field(description="Filter by managed status")] = None, filter_discovery_snmp : Annotated[Optional[StrictStr], Field(description="Filter by the device’s SNMP discovery status.")] = None, filter_discovery_wmi : Annotated[Optional[StrictStr], Field(description="Filter by the device’s WMI discovery status.")] = None, filter_discovery_login : Annotated[Optional[StrictStr], Field(description="Filter by the device’s Login discovery status.")] = None, filter_discovery_v_mware : Annotated[Optional[StrictStr], Field(description="Filter by the device’s VMware discovery status.")] = None, filter_traffic_insights_status : Annotated[Optional[StrictStr], Field(description="Filter by the device’s TrafficInsights status.")] = None, tenants : Annotated[Optional[StrictStr], Field(description="Comma delimited list of tenant IDs to request info from.")] = None, page_first : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="For paginated responses, the first N elements will be returned. Used in combination with <code>page[after]</code>.")] = None, page_after : Annotated[Optional[StrictStr], Field(description="Cursor after which elements will be returned as a page. The page size is provided by <code>page[first]</code>.")] = None, page_last : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="For paginated responses, the last N services will be returned. Used in combination with <code>page[before]</code>.")] = None, page_before : Annotated[Optional[StrictStr], Field(description="Cursor before which elements will be returned as a page. The page size is provided by <code>page[last]</code>.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Read Multiple Devices’ Details  # noqa: E501

        Use the Read Multiple Devices’ Details API to pull extra collected information about the various devices Auvik has discovered not already included in the Device Info API. You’ll need the client IDs for the clients you want to run the multiple read against.<br> <br> To find the client IDs, run the <a href=\"#operation/readMultipleTenants\">Read Multiple Tenants API.</a><br> <br> Looking at the detail screen on the right, click cURL to see the command that will be used. Click <b>Copy</b> to copy the details of the command to your clipboard. Be sure to edit the following parameters within the command: <ul>     <li>Within the API URL, <b>us1.my</b> (https://auvikapi.us1.my.auvik.com) should be updated to match the region in which your account resides. To locate the region, log into your Auvik dashboard and look at the URL in your browser’s address bar.</li>     <li><i>user@example.com</i> should be the email address of a user with permissions to view device details.</li>     <li><i>apiKey</i> should be the API key that’s been set for the user.</li>     <li><i>195798545063742726</i> should be the ID or comma delimited IDs of the client(s) whose data you wish to fetch information from. </li>     <li><i>filter[deviceType]=router</i> should be whichever key and value pair you want to filter the result set by. See below for a list of filterable parameters.</li> </ul>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.read_multiple_device_details_with_http_info(filter_manage_status, filter_discovery_snmp, filter_discovery_wmi, filter_discovery_login, filter_discovery_v_mware, filter_traffic_insights_status, tenants, page_first, page_after, page_last, page_before, async_req=True)
        >>> result = thread.get()

        :param filter_manage_status: Filter by managed status
        :type filter_manage_status: bool
        :param filter_discovery_snmp: Filter by the device’s SNMP discovery status.
        :type filter_discovery_snmp: str
        :param filter_discovery_wmi: Filter by the device’s WMI discovery status.
        :type filter_discovery_wmi: str
        :param filter_discovery_login: Filter by the device’s Login discovery status.
        :type filter_discovery_login: str
        :param filter_discovery_v_mware: Filter by the device’s VMware discovery status.
        :type filter_discovery_v_mware: str
        :param filter_traffic_insights_status: Filter by the device’s TrafficInsights status.
        :type filter_traffic_insights_status: str
        :param tenants: Comma delimited list of tenant IDs to request info from.
        :type tenants: str
        :param page_first: For paginated responses, the first N elements will be returned. Used in combination with <code>page[after]</code>.
        :type page_first: float
        :param page_after: Cursor after which elements will be returned as a page. The page size is provided by <code>page[first]</code>.
        :type page_after: str
        :param page_last: For paginated responses, the last N services will be returned. Used in combination with <code>page[before]</code>.
        :type page_last: float
        :param page_before: Cursor before which elements will be returned as a page. The page size is provided by <code>page[last]</code>.
        :type page_before: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DeviceDetailsReadMultiple, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'filter_manage_status',
            'filter_discovery_snmp',
            'filter_discovery_wmi',
            'filter_discovery_login',
            'filter_discovery_v_mware',
            'filter_traffic_insights_status',
            'tenants',
            'page_first',
            'page_after',
            'page_last',
            'page_before'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_multiple_device_details" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('filter_manage_status') is not None:  # noqa: E501
            _query_params.append(('filter[manageStatus]', _params['filter_manage_status']))

        if _params.get('filter_discovery_snmp') is not None:  # noqa: E501
            _query_params.append(('filter[discoverySNMP]', _params['filter_discovery_snmp']))

        if _params.get('filter_discovery_wmi') is not None:  # noqa: E501
            _query_params.append(('filter[discoveryWMI]', _params['filter_discovery_wmi']))

        if _params.get('filter_discovery_login') is not None:  # noqa: E501
            _query_params.append(('filter[discoveryLogin]', _params['filter_discovery_login']))

        if _params.get('filter_discovery_v_mware') is not None:  # noqa: E501
            _query_params.append(('filter[discoveryVMware]', _params['filter_discovery_v_mware']))

        if _params.get('filter_traffic_insights_status') is not None:  # noqa: E501
            _query_params.append(('filter[trafficInsightsStatus]', _params['filter_traffic_insights_status']))

        if _params.get('tenants') is not None:  # noqa: E501
            _query_params.append(('tenants', _params['tenants']))

        if _params.get('page_first') is not None:  # noqa: E501
            _query_params.append(('page[first]', _params['page_first']))

        if _params.get('page_after') is not None:  # noqa: E501
            _query_params.append(('page[after]', _params['page_after']))

        if _params.get('page_last') is not None:  # noqa: E501
            _query_params.append(('page[last]', _params['page_last']))

        if _params.get('page_before') is not None:  # noqa: E501
            _query_params.append(('page[before]', _params['page_before']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/vnd.api+json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['ApiKey']  # noqa: E501

        _response_types_map = {
            '200': "DeviceDetailsReadMultiple",
            '400': "BasicError",
            '403': "BasicError",
            '404': "BasicError",
            '500': None,
        }

        return self.api_client.call_api(
            '/inventory/device/detail', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def read_multiple_device_extended_detail(self, filter_device_type : Annotated[DeviceTypeSchema, Field(..., description="Filter by device type.")], filter_modified_after : Annotated[Optional[StrictStr], Field(description="Filter by date and time, only returning entities modified after provided value.")] = None, filter_not_seen_since : Annotated[Optional[StrictStr], Field(description="Filter by the last seen online time, returning entities not seen online after the provided value.")] = None, tenants : Annotated[Optional[StrictStr], Field(description="Comma delimited list of tenant IDs to request info from.")] = None, page_first : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="For paginated responses, the first N elements will be returned. Used in combination with <code>page[after]</code>.")] = None, page_after : Annotated[Optional[StrictStr], Field(description="Cursor after which elements will be returned as a page. The page size is provided by <code>page[first]</code>.")] = None, page_last : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="For paginated responses, the last N services will be returned. Used in combination with <code>page[before]</code>.")] = None, page_before : Annotated[Optional[StrictStr], Field(description="Cursor before which elements will be returned as a page. The page size is provided by <code>page[last]</code>.")] = None, **kwargs) -> DeviceDetailsExtendedReadMultiple:  # noqa: E501
        """Read Multiple Devices’ Extended Details  # noqa: E501

        Use the Read Multiple Devices’ Extended Details API to get many devices’ extended details. Many device types have information collected and tracked by Auvik that are unique to that device type. Use this endpoint to access such information for a given device. You’ll need the client IDs for the clients you want to run the multiple read against.<br> <br> To find the client IDs, run the <a href=\"#operation/readMultipleTenants\">Read Multiple Tenants API.</a><br> <br> Looking at the detail screen on the right, click cURL to see the command that will be used. Click <b>Copy</b> to copy the details of the command to your clipboard. Be sure to edit the following parameters within the command: <ul>     <li>Within the API URL, <b>us1.my</b> (https://auvikapi.us1.my.auvik.com) should be updated to match the region in which your account resides. To locate the region, log into your Auvik dashboard and look at the URL in your browser’s address bar.</li>     <li><i>user@example.com</i> should be the email address of a user with permissions to view device extended details.</li>     <li><i>apiKey</i> should be the API key that’s been set for the user.</li>     <li><i>195798545063742726</i> should be the ID or comma delimited IDs of the client(s) whose data you wish to fetch information from. </li>     <li><i>filter[deviceType]=switch</i> should be whichever key and value pair you want to filter the result set by. See below for a list of filterable parameters.</li> </ul>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.read_multiple_device_extended_detail(filter_device_type, filter_modified_after, filter_not_seen_since, tenants, page_first, page_after, page_last, page_before, async_req=True)
        >>> result = thread.get()

        :param filter_device_type: Filter by device type. (required)
        :type filter_device_type: DeviceTypeSchema
        :param filter_modified_after: Filter by date and time, only returning entities modified after provided value.
        :type filter_modified_after: str
        :param filter_not_seen_since: Filter by the last seen online time, returning entities not seen online after the provided value.
        :type filter_not_seen_since: str
        :param tenants: Comma delimited list of tenant IDs to request info from.
        :type tenants: str
        :param page_first: For paginated responses, the first N elements will be returned. Used in combination with <code>page[after]</code>.
        :type page_first: float
        :param page_after: Cursor after which elements will be returned as a page. The page size is provided by <code>page[first]</code>.
        :type page_after: str
        :param page_last: For paginated responses, the last N services will be returned. Used in combination with <code>page[before]</code>.
        :type page_last: float
        :param page_before: Cursor before which elements will be returned as a page. The page size is provided by <code>page[last]</code>.
        :type page_before: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DeviceDetailsExtendedReadMultiple
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the read_multiple_device_extended_detail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.read_multiple_device_extended_detail_with_http_info(filter_device_type, filter_modified_after, filter_not_seen_since, tenants, page_first, page_after, page_last, page_before, **kwargs)  # noqa: E501

    @validate_arguments
    def read_multiple_device_extended_detail_with_http_info(self, filter_device_type : Annotated[DeviceTypeSchema, Field(..., description="Filter by device type.")], filter_modified_after : Annotated[Optional[StrictStr], Field(description="Filter by date and time, only returning entities modified after provided value.")] = None, filter_not_seen_since : Annotated[Optional[StrictStr], Field(description="Filter by the last seen online time, returning entities not seen online after the provided value.")] = None, tenants : Annotated[Optional[StrictStr], Field(description="Comma delimited list of tenant IDs to request info from.")] = None, page_first : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="For paginated responses, the first N elements will be returned. Used in combination with <code>page[after]</code>.")] = None, page_after : Annotated[Optional[StrictStr], Field(description="Cursor after which elements will be returned as a page. The page size is provided by <code>page[first]</code>.")] = None, page_last : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="For paginated responses, the last N services will be returned. Used in combination with <code>page[before]</code>.")] = None, page_before : Annotated[Optional[StrictStr], Field(description="Cursor before which elements will be returned as a page. The page size is provided by <code>page[last]</code>.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Read Multiple Devices’ Extended Details  # noqa: E501

        Use the Read Multiple Devices’ Extended Details API to get many devices’ extended details. Many device types have information collected and tracked by Auvik that are unique to that device type. Use this endpoint to access such information for a given device. You’ll need the client IDs for the clients you want to run the multiple read against.<br> <br> To find the client IDs, run the <a href=\"#operation/readMultipleTenants\">Read Multiple Tenants API.</a><br> <br> Looking at the detail screen on the right, click cURL to see the command that will be used. Click <b>Copy</b> to copy the details of the command to your clipboard. Be sure to edit the following parameters within the command: <ul>     <li>Within the API URL, <b>us1.my</b> (https://auvikapi.us1.my.auvik.com) should be updated to match the region in which your account resides. To locate the region, log into your Auvik dashboard and look at the URL in your browser’s address bar.</li>     <li><i>user@example.com</i> should be the email address of a user with permissions to view device extended details.</li>     <li><i>apiKey</i> should be the API key that’s been set for the user.</li>     <li><i>195798545063742726</i> should be the ID or comma delimited IDs of the client(s) whose data you wish to fetch information from. </li>     <li><i>filter[deviceType]=switch</i> should be whichever key and value pair you want to filter the result set by. See below for a list of filterable parameters.</li> </ul>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.read_multiple_device_extended_detail_with_http_info(filter_device_type, filter_modified_after, filter_not_seen_since, tenants, page_first, page_after, page_last, page_before, async_req=True)
        >>> result = thread.get()

        :param filter_device_type: Filter by device type. (required)
        :type filter_device_type: DeviceTypeSchema
        :param filter_modified_after: Filter by date and time, only returning entities modified after provided value.
        :type filter_modified_after: str
        :param filter_not_seen_since: Filter by the last seen online time, returning entities not seen online after the provided value.
        :type filter_not_seen_since: str
        :param tenants: Comma delimited list of tenant IDs to request info from.
        :type tenants: str
        :param page_first: For paginated responses, the first N elements will be returned. Used in combination with <code>page[after]</code>.
        :type page_first: float
        :param page_after: Cursor after which elements will be returned as a page. The page size is provided by <code>page[first]</code>.
        :type page_after: str
        :param page_last: For paginated responses, the last N services will be returned. Used in combination with <code>page[before]</code>.
        :type page_last: float
        :param page_before: Cursor before which elements will be returned as a page. The page size is provided by <code>page[last]</code>.
        :type page_before: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DeviceDetailsExtendedReadMultiple, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'filter_device_type',
            'filter_modified_after',
            'filter_not_seen_since',
            'tenants',
            'page_first',
            'page_after',
            'page_last',
            'page_before'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_multiple_device_extended_detail" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('filter_device_type') is not None:  # noqa: E501
            _query_params.append(('filter[deviceType]', _params['filter_device_type'].value))

        if _params.get('filter_modified_after') is not None:  # noqa: E501
            _query_params.append(('filter[modifiedAfter]', _params['filter_modified_after']))

        if _params.get('filter_not_seen_since') is not None:  # noqa: E501
            _query_params.append(('filter[notSeenSince]', _params['filter_not_seen_since']))

        if _params.get('tenants') is not None:  # noqa: E501
            _query_params.append(('tenants', _params['tenants']))

        if _params.get('page_first') is not None:  # noqa: E501
            _query_params.append(('page[first]', _params['page_first']))

        if _params.get('page_after') is not None:  # noqa: E501
            _query_params.append(('page[after]', _params['page_after']))

        if _params.get('page_last') is not None:  # noqa: E501
            _query_params.append(('page[last]', _params['page_last']))

        if _params.get('page_before') is not None:  # noqa: E501
            _query_params.append(('page[before]', _params['page_before']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/vnd.api+json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['ApiKey']  # noqa: E501

        _response_types_map = {
            '200': "DeviceDetailsExtendedReadMultiple",
            '400': "BasicError",
            '403': "BasicError",
            '404': "BasicError",
            '500': None,
        }

        return self.api_client.call_api(
            '/inventory/device/detail/extended', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def read_multiple_device_info(self, filter_networks : Annotated[Optional[StrictStr], Field(description="Filter by IDs of networks this device is on.")] = None, filter_device_type : Annotated[Optional[DeviceTypeSchema], Field(description="Filter by device type.")] = None, filter_make_model : Annotated[Optional[StrictStr], Field(description="Filter by the device’s make and model.")] = None, filter_vendor_name : Annotated[Optional[StrictStr], Field(description="Filter by the device’s vendor/manufacturer.")] = None, filter_online_status : Annotated[Optional[StrictStr], Field(description="Filter by the device’s online status.")] = None, filter_modified_after : Annotated[Optional[StrictStr], Field(description="Filter by date and time, only returning entities modified after provided value.")] = None, filter_not_seen_since : Annotated[Optional[StrictStr], Field(description="Filter by the last seen online time, returning entities not seen online after the provided value.")] = None, tenants : Annotated[Optional[StrictStr], Field(description="Comma delimited list of tenant IDs to request info from.")] = None, page_first : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="For paginated responses, the first N elements will be returned. Used in combination with <code>page[after]</code>.")] = None, page_after : Annotated[Optional[StrictStr], Field(description="Cursor after which elements will be returned as a page. The page size is provided by <code>page[first]</code>.")] = None, page_last : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="For paginated responses, the last N services will be returned. Used in combination with <code>page[before]</code>.")] = None, page_before : Annotated[Optional[StrictStr], Field(description="Cursor before which elements will be returned as a page. The page size is provided by <code>page[last]</code>.")] = None, include : Annotated[Optional[StrictStr], Field(description="Use to include the full resource objects of the list device relationships.")] = None, fields_device_detail : Annotated[Optional[StrictStr], Field(description="Use to limit the attributes that will be returned in the included detail object to only what is specified by this query parameter. Requires <code>include=deviceDetail</code>")] = None, **kwargs) -> DeviceInfoReadMultiple:  # noqa: E501
        """Read Multiple Devices’ Info  # noqa: E501

        Use the Read Multiple Devices’ Info API to pull the collected information about the various devices Auvik has discovered. You’ll need the client IDs for the clients you want to run the multiple read against.<br> <br> To find the client IDs, run the <a href=\"#operation/readMultipleTenants\">Read Multiple Tenants API.</a><br> <br> Looking at the detail screen on the right, click cURL to see the command that will be used. Click <b>Copy</b> to copy the details of the command to your clipboard. Be sure to edit the following parameters within the command: <ul>     <li>Within the API URL, <b>us1.my</b> (https://auvikapi.us1.my.auvik.com) should be updated to match the region in which your account resides. To locate the region, log into your Auvik dashboard and look at the URL in your browser’s address bar.</li>     <li><i>user@example.com</i> should be the email address of a user with permissions to view device information.</li>     <li><i>apiKey</i> should be the API key that’s been set for the user.</li>     <li><i>195798545063742726</i> should be the ID or comma delimited IDs of the client(s) whose data you wish to fetch information from. </li>     <li><i>filter[deviceType]=router</i> should be whichever key and value pair you want to filter the result set by. See below for a list of filterable parameters.</li> </ul>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.read_multiple_device_info(filter_networks, filter_device_type, filter_make_model, filter_vendor_name, filter_online_status, filter_modified_after, filter_not_seen_since, tenants, page_first, page_after, page_last, page_before, include, fields_device_detail, async_req=True)
        >>> result = thread.get()

        :param filter_networks: Filter by IDs of networks this device is on.
        :type filter_networks: str
        :param filter_device_type: Filter by device type.
        :type filter_device_type: DeviceTypeSchema
        :param filter_make_model: Filter by the device’s make and model.
        :type filter_make_model: str
        :param filter_vendor_name: Filter by the device’s vendor/manufacturer.
        :type filter_vendor_name: str
        :param filter_online_status: Filter by the device’s online status.
        :type filter_online_status: str
        :param filter_modified_after: Filter by date and time, only returning entities modified after provided value.
        :type filter_modified_after: str
        :param filter_not_seen_since: Filter by the last seen online time, returning entities not seen online after the provided value.
        :type filter_not_seen_since: str
        :param tenants: Comma delimited list of tenant IDs to request info from.
        :type tenants: str
        :param page_first: For paginated responses, the first N elements will be returned. Used in combination with <code>page[after]</code>.
        :type page_first: float
        :param page_after: Cursor after which elements will be returned as a page. The page size is provided by <code>page[first]</code>.
        :type page_after: str
        :param page_last: For paginated responses, the last N services will be returned. Used in combination with <code>page[before]</code>.
        :type page_last: float
        :param page_before: Cursor before which elements will be returned as a page. The page size is provided by <code>page[last]</code>.
        :type page_before: str
        :param include: Use to include the full resource objects of the list device relationships.
        :type include: str
        :param fields_device_detail: Use to limit the attributes that will be returned in the included detail object to only what is specified by this query parameter. Requires <code>include=deviceDetail</code>
        :type fields_device_detail: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DeviceInfoReadMultiple
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the read_multiple_device_info_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.read_multiple_device_info_with_http_info(filter_networks, filter_device_type, filter_make_model, filter_vendor_name, filter_online_status, filter_modified_after, filter_not_seen_since, tenants, page_first, page_after, page_last, page_before, include, fields_device_detail, **kwargs)  # noqa: E501

    @validate_arguments
    def read_multiple_device_info_with_http_info(self, filter_networks : Annotated[Optional[StrictStr], Field(description="Filter by IDs of networks this device is on.")] = None, filter_device_type : Annotated[Optional[DeviceTypeSchema], Field(description="Filter by device type.")] = None, filter_make_model : Annotated[Optional[StrictStr], Field(description="Filter by the device’s make and model.")] = None, filter_vendor_name : Annotated[Optional[StrictStr], Field(description="Filter by the device’s vendor/manufacturer.")] = None, filter_online_status : Annotated[Optional[StrictStr], Field(description="Filter by the device’s online status.")] = None, filter_modified_after : Annotated[Optional[StrictStr], Field(description="Filter by date and time, only returning entities modified after provided value.")] = None, filter_not_seen_since : Annotated[Optional[StrictStr], Field(description="Filter by the last seen online time, returning entities not seen online after the provided value.")] = None, tenants : Annotated[Optional[StrictStr], Field(description="Comma delimited list of tenant IDs to request info from.")] = None, page_first : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="For paginated responses, the first N elements will be returned. Used in combination with <code>page[after]</code>.")] = None, page_after : Annotated[Optional[StrictStr], Field(description="Cursor after which elements will be returned as a page. The page size is provided by <code>page[first]</code>.")] = None, page_last : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="For paginated responses, the last N services will be returned. Used in combination with <code>page[before]</code>.")] = None, page_before : Annotated[Optional[StrictStr], Field(description="Cursor before which elements will be returned as a page. The page size is provided by <code>page[last]</code>.")] = None, include : Annotated[Optional[StrictStr], Field(description="Use to include the full resource objects of the list device relationships.")] = None, fields_device_detail : Annotated[Optional[StrictStr], Field(description="Use to limit the attributes that will be returned in the included detail object to only what is specified by this query parameter. Requires <code>include=deviceDetail</code>")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Read Multiple Devices’ Info  # noqa: E501

        Use the Read Multiple Devices’ Info API to pull the collected information about the various devices Auvik has discovered. You’ll need the client IDs for the clients you want to run the multiple read against.<br> <br> To find the client IDs, run the <a href=\"#operation/readMultipleTenants\">Read Multiple Tenants API.</a><br> <br> Looking at the detail screen on the right, click cURL to see the command that will be used. Click <b>Copy</b> to copy the details of the command to your clipboard. Be sure to edit the following parameters within the command: <ul>     <li>Within the API URL, <b>us1.my</b> (https://auvikapi.us1.my.auvik.com) should be updated to match the region in which your account resides. To locate the region, log into your Auvik dashboard and look at the URL in your browser’s address bar.</li>     <li><i>user@example.com</i> should be the email address of a user with permissions to view device information.</li>     <li><i>apiKey</i> should be the API key that’s been set for the user.</li>     <li><i>195798545063742726</i> should be the ID or comma delimited IDs of the client(s) whose data you wish to fetch information from. </li>     <li><i>filter[deviceType]=router</i> should be whichever key and value pair you want to filter the result set by. See below for a list of filterable parameters.</li> </ul>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.read_multiple_device_info_with_http_info(filter_networks, filter_device_type, filter_make_model, filter_vendor_name, filter_online_status, filter_modified_after, filter_not_seen_since, tenants, page_first, page_after, page_last, page_before, include, fields_device_detail, async_req=True)
        >>> result = thread.get()

        :param filter_networks: Filter by IDs of networks this device is on.
        :type filter_networks: str
        :param filter_device_type: Filter by device type.
        :type filter_device_type: DeviceTypeSchema
        :param filter_make_model: Filter by the device’s make and model.
        :type filter_make_model: str
        :param filter_vendor_name: Filter by the device’s vendor/manufacturer.
        :type filter_vendor_name: str
        :param filter_online_status: Filter by the device’s online status.
        :type filter_online_status: str
        :param filter_modified_after: Filter by date and time, only returning entities modified after provided value.
        :type filter_modified_after: str
        :param filter_not_seen_since: Filter by the last seen online time, returning entities not seen online after the provided value.
        :type filter_not_seen_since: str
        :param tenants: Comma delimited list of tenant IDs to request info from.
        :type tenants: str
        :param page_first: For paginated responses, the first N elements will be returned. Used in combination with <code>page[after]</code>.
        :type page_first: float
        :param page_after: Cursor after which elements will be returned as a page. The page size is provided by <code>page[first]</code>.
        :type page_after: str
        :param page_last: For paginated responses, the last N services will be returned. Used in combination with <code>page[before]</code>.
        :type page_last: float
        :param page_before: Cursor before which elements will be returned as a page. The page size is provided by <code>page[last]</code>.
        :type page_before: str
        :param include: Use to include the full resource objects of the list device relationships.
        :type include: str
        :param fields_device_detail: Use to limit the attributes that will be returned in the included detail object to only what is specified by this query parameter. Requires <code>include=deviceDetail</code>
        :type fields_device_detail: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DeviceInfoReadMultiple, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'filter_networks',
            'filter_device_type',
            'filter_make_model',
            'filter_vendor_name',
            'filter_online_status',
            'filter_modified_after',
            'filter_not_seen_since',
            'tenants',
            'page_first',
            'page_after',
            'page_last',
            'page_before',
            'include',
            'fields_device_detail'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_multiple_device_info" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('filter_networks') is not None:  # noqa: E501
            _query_params.append(('filter[networks]', _params['filter_networks']))

        if _params.get('filter_device_type') is not None:  # noqa: E501
            _query_params.append(('filter[deviceType]', _params['filter_device_type'].value))

        if _params.get('filter_make_model') is not None:  # noqa: E501
            _query_params.append(('filter[makeModel]', _params['filter_make_model']))

        if _params.get('filter_vendor_name') is not None:  # noqa: E501
            _query_params.append(('filter[vendorName]', _params['filter_vendor_name']))

        if _params.get('filter_online_status') is not None:  # noqa: E501
            _query_params.append(('filter[onlineStatus]', _params['filter_online_status']))

        if _params.get('filter_modified_after') is not None:  # noqa: E501
            _query_params.append(('filter[modifiedAfter]', _params['filter_modified_after']))

        if _params.get('filter_not_seen_since') is not None:  # noqa: E501
            _query_params.append(('filter[notSeenSince]', _params['filter_not_seen_since']))

        if _params.get('tenants') is not None:  # noqa: E501
            _query_params.append(('tenants', _params['tenants']))

        if _params.get('page_first') is not None:  # noqa: E501
            _query_params.append(('page[first]', _params['page_first']))

        if _params.get('page_after') is not None:  # noqa: E501
            _query_params.append(('page[after]', _params['page_after']))

        if _params.get('page_last') is not None:  # noqa: E501
            _query_params.append(('page[last]', _params['page_last']))

        if _params.get('page_before') is not None:  # noqa: E501
            _query_params.append(('page[before]', _params['page_before']))

        if _params.get('include') is not None:  # noqa: E501
            _query_params.append(('include', _params['include']))

        if _params.get('fields_device_detail') is not None:  # noqa: E501
            _query_params.append(('fields[deviceDetail]', _params['fields_device_detail']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/vnd.api+json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['ApiKey']  # noqa: E501

        _response_types_map = {
            '200': "DeviceInfoReadMultiple",
            '400': "BasicError",
            '403': "BasicError",
            '404': "BasicError",
            '500': None,
        }

        return self.api_client.call_api(
            '/inventory/device/info', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def read_multiple_device_lifecycle(self, filter_sales_availability : Annotated[Optional[StrictStr], Field(description="Filter by sales availability.")] = None, filter_software_maintenance_status : Annotated[Optional[StrictStr], Field(description="Filter by software maintenance status.")] = None, filter_security_software_maintenance_status : Annotated[Optional[StrictStr], Field(description="Filter by security software maintenance status.")] = None, filter_last_support_status : Annotated[Optional[StrictStr], Field(description="Filter by last support status.")] = None, tenants : Annotated[Optional[StrictStr], Field(description="Comma delimited list of tenant IDs to request info from.")] = None, page_first : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="For paginated responses, the first N elements will be returned. Used in combination with <code>page[after]</code>.")] = None, page_after : Annotated[Optional[StrictStr], Field(description="Cursor after which elements will be returned as a page. The page size is provided by <code>page[first]</code>.")] = None, page_last : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="For paginated responses, the last N services will be returned. Used in combination with <code>page[before]</code>.")] = None, page_before : Annotated[Optional[StrictStr], Field(description="Cursor before which elements will be returned as a page. The page size is provided by <code>page[last]</code>.")] = None, **kwargs) -> DeviceLifecycleReadMultiple:  # noqa: E501
        """Read Multiple Devices’ Lifecycle Info  # noqa: E501

        Use the Read Multiple Devices’ Lifecycle API to pull the collected lifecycle information about the various devices Auvik has discovered. You’ll need the client IDs for the clients you want to run the multiple read against.<br> <br> To find the client IDs, run the <a href=\"#operation/readMultipleTenants\">Read Multiple Tenants API.</a><br> <br> Looking at the detail screen on the right, click cURL to see the command that will be used. Click <b>Copy</b> to copy the details of the command to your clipboard. Be sure to edit the following parameters within the command: <ul>     <li>Within the API URL, <b>us1.my</b> (https://auvikapi.us1.my.auvik.com) should be updated to match the region in which your account resides. To locate the region, log into your Auvik dashboard and look at the URL in your browser’s address bar.</li>     <li><i>user@example.com</i> should be the email address of a user with permissions to view device information.</li>     <li><i>apiKey</i> should be the API key that’s been set for the user.</li>     <li><i>195798545063742726</i> should be the ID or comma delimited IDs of the client(s) whose data you wish to fetch information from. </li>     <li><i>filter[salesAvailability]=available</i> should be whichever key and value pair you want to filter the result set by. See below for a list of filterable parameters.</li> </ul>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.read_multiple_device_lifecycle(filter_sales_availability, filter_software_maintenance_status, filter_security_software_maintenance_status, filter_last_support_status, tenants, page_first, page_after, page_last, page_before, async_req=True)
        >>> result = thread.get()

        :param filter_sales_availability: Filter by sales availability.
        :type filter_sales_availability: str
        :param filter_software_maintenance_status: Filter by software maintenance status.
        :type filter_software_maintenance_status: str
        :param filter_security_software_maintenance_status: Filter by security software maintenance status.
        :type filter_security_software_maintenance_status: str
        :param filter_last_support_status: Filter by last support status.
        :type filter_last_support_status: str
        :param tenants: Comma delimited list of tenant IDs to request info from.
        :type tenants: str
        :param page_first: For paginated responses, the first N elements will be returned. Used in combination with <code>page[after]</code>.
        :type page_first: float
        :param page_after: Cursor after which elements will be returned as a page. The page size is provided by <code>page[first]</code>.
        :type page_after: str
        :param page_last: For paginated responses, the last N services will be returned. Used in combination with <code>page[before]</code>.
        :type page_last: float
        :param page_before: Cursor before which elements will be returned as a page. The page size is provided by <code>page[last]</code>.
        :type page_before: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DeviceLifecycleReadMultiple
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the read_multiple_device_lifecycle_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.read_multiple_device_lifecycle_with_http_info(filter_sales_availability, filter_software_maintenance_status, filter_security_software_maintenance_status, filter_last_support_status, tenants, page_first, page_after, page_last, page_before, **kwargs)  # noqa: E501

    @validate_arguments
    def read_multiple_device_lifecycle_with_http_info(self, filter_sales_availability : Annotated[Optional[StrictStr], Field(description="Filter by sales availability.")] = None, filter_software_maintenance_status : Annotated[Optional[StrictStr], Field(description="Filter by software maintenance status.")] = None, filter_security_software_maintenance_status : Annotated[Optional[StrictStr], Field(description="Filter by security software maintenance status.")] = None, filter_last_support_status : Annotated[Optional[StrictStr], Field(description="Filter by last support status.")] = None, tenants : Annotated[Optional[StrictStr], Field(description="Comma delimited list of tenant IDs to request info from.")] = None, page_first : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="For paginated responses, the first N elements will be returned. Used in combination with <code>page[after]</code>.")] = None, page_after : Annotated[Optional[StrictStr], Field(description="Cursor after which elements will be returned as a page. The page size is provided by <code>page[first]</code>.")] = None, page_last : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="For paginated responses, the last N services will be returned. Used in combination with <code>page[before]</code>.")] = None, page_before : Annotated[Optional[StrictStr], Field(description="Cursor before which elements will be returned as a page. The page size is provided by <code>page[last]</code>.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Read Multiple Devices’ Lifecycle Info  # noqa: E501

        Use the Read Multiple Devices’ Lifecycle API to pull the collected lifecycle information about the various devices Auvik has discovered. You’ll need the client IDs for the clients you want to run the multiple read against.<br> <br> To find the client IDs, run the <a href=\"#operation/readMultipleTenants\">Read Multiple Tenants API.</a><br> <br> Looking at the detail screen on the right, click cURL to see the command that will be used. Click <b>Copy</b> to copy the details of the command to your clipboard. Be sure to edit the following parameters within the command: <ul>     <li>Within the API URL, <b>us1.my</b> (https://auvikapi.us1.my.auvik.com) should be updated to match the region in which your account resides. To locate the region, log into your Auvik dashboard and look at the URL in your browser’s address bar.</li>     <li><i>user@example.com</i> should be the email address of a user with permissions to view device information.</li>     <li><i>apiKey</i> should be the API key that’s been set for the user.</li>     <li><i>195798545063742726</i> should be the ID or comma delimited IDs of the client(s) whose data you wish to fetch information from. </li>     <li><i>filter[salesAvailability]=available</i> should be whichever key and value pair you want to filter the result set by. See below for a list of filterable parameters.</li> </ul>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.read_multiple_device_lifecycle_with_http_info(filter_sales_availability, filter_software_maintenance_status, filter_security_software_maintenance_status, filter_last_support_status, tenants, page_first, page_after, page_last, page_before, async_req=True)
        >>> result = thread.get()

        :param filter_sales_availability: Filter by sales availability.
        :type filter_sales_availability: str
        :param filter_software_maintenance_status: Filter by software maintenance status.
        :type filter_software_maintenance_status: str
        :param filter_security_software_maintenance_status: Filter by security software maintenance status.
        :type filter_security_software_maintenance_status: str
        :param filter_last_support_status: Filter by last support status.
        :type filter_last_support_status: str
        :param tenants: Comma delimited list of tenant IDs to request info from.
        :type tenants: str
        :param page_first: For paginated responses, the first N elements will be returned. Used in combination with <code>page[after]</code>.
        :type page_first: float
        :param page_after: Cursor after which elements will be returned as a page. The page size is provided by <code>page[first]</code>.
        :type page_after: str
        :param page_last: For paginated responses, the last N services will be returned. Used in combination with <code>page[before]</code>.
        :type page_last: float
        :param page_before: Cursor before which elements will be returned as a page. The page size is provided by <code>page[last]</code>.
        :type page_before: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DeviceLifecycleReadMultiple, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'filter_sales_availability',
            'filter_software_maintenance_status',
            'filter_security_software_maintenance_status',
            'filter_last_support_status',
            'tenants',
            'page_first',
            'page_after',
            'page_last',
            'page_before'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_multiple_device_lifecycle" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('filter_sales_availability') is not None:  # noqa: E501
            _query_params.append(('filter[salesAvailability]', _params['filter_sales_availability']))

        if _params.get('filter_software_maintenance_status') is not None:  # noqa: E501
            _query_params.append(('filter[softwareMaintenanceStatus]', _params['filter_software_maintenance_status']))

        if _params.get('filter_security_software_maintenance_status') is not None:  # noqa: E501
            _query_params.append(('filter[securitySoftwareMaintenanceStatus]', _params['filter_security_software_maintenance_status']))

        if _params.get('filter_last_support_status') is not None:  # noqa: E501
            _query_params.append(('filter[lastSupportStatus]', _params['filter_last_support_status']))

        if _params.get('tenants') is not None:  # noqa: E501
            _query_params.append(('tenants', _params['tenants']))

        if _params.get('page_first') is not None:  # noqa: E501
            _query_params.append(('page[first]', _params['page_first']))

        if _params.get('page_after') is not None:  # noqa: E501
            _query_params.append(('page[after]', _params['page_after']))

        if _params.get('page_last') is not None:  # noqa: E501
            _query_params.append(('page[last]', _params['page_last']))

        if _params.get('page_before') is not None:  # noqa: E501
            _query_params.append(('page[before]', _params['page_before']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/vnd.api+json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['ApiKey']  # noqa: E501

        _response_types_map = {
            '200': "DeviceLifecycleReadMultiple",
            '400': "BasicError",
            '403': "BasicError",
            '404': "BasicError",
            '500': None,
        }

        return self.api_client.call_api(
            '/inventory/device/lifecycle', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def read_multiple_device_warranty(self, filter_covered_under_warranty : Annotated[Optional[StrictBool], Field(description="Filter by warranty coverage status.")] = None, filter_covered_under_service : Annotated[Optional[StrictBool], Field(description="Filter by service coverage status.")] = None, tenants : Annotated[Optional[StrictStr], Field(description="Comma delimited list of tenant IDs to request info from.")] = None, page_first : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="For paginated responses, the first N elements will be returned. Used in combination with <code>page[after]</code>.")] = None, page_after : Annotated[Optional[StrictStr], Field(description="Cursor after which elements will be returned as a page. The page size is provided by <code>page[first]</code>.")] = None, page_last : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="For paginated responses, the last N services will be returned. Used in combination with <code>page[before]</code>.")] = None, page_before : Annotated[Optional[StrictStr], Field(description="Cursor before which elements will be returned as a page. The page size is provided by <code>page[last]</code>.")] = None, **kwargs) -> DeviceWarrantyReadMultiple:  # noqa: E501
        """Read Multiple Devices’ Warranty Info  # noqa: E501

        Use the Read Multiple Devices’ Warranty API to pull the collected warranty information about the various devices Auvik has discovered. You’ll need the client IDs for the clients you want to run the multiple read against.<br> <br> To find the client IDs, run the <a href=\"#operation/readMultipleTenants\">Read Multiple Tenants API.</a><br> <br> Looking at the detail screen on the right, click cURL to see the command that will be used. Click <b>Copy</b> to copy the details of the command to your clipboard. Be sure to edit the following parameters within the command: <ul>     <li>Within the API URL, <b>us1.my</b> (https://auvikapi.us1.my.auvik.com) should be updated to match the region in which your account resides. To locate the region, log into your Auvik dashboard and look at the URL in your browser’s address bar.</li>     <li><i>user@example.com</i> should be the email address of a user with permissions to view device information.</li>     <li><i>apiKey</i> should be the API key that’s been set for the user.</li>     <li><i>195798545063742726</i> should be the ID or comma delimited IDs of the client(s) whose data you wish to fetch information from. </li>     <li><i>filter[coveredUnderWarranty]=true</i> should be whichever key and value pair you want to filter the result set by. See below for a list of filterable parameters.</li> </ul>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.read_multiple_device_warranty(filter_covered_under_warranty, filter_covered_under_service, tenants, page_first, page_after, page_last, page_before, async_req=True)
        >>> result = thread.get()

        :param filter_covered_under_warranty: Filter by warranty coverage status.
        :type filter_covered_under_warranty: bool
        :param filter_covered_under_service: Filter by service coverage status.
        :type filter_covered_under_service: bool
        :param tenants: Comma delimited list of tenant IDs to request info from.
        :type tenants: str
        :param page_first: For paginated responses, the first N elements will be returned. Used in combination with <code>page[after]</code>.
        :type page_first: float
        :param page_after: Cursor after which elements will be returned as a page. The page size is provided by <code>page[first]</code>.
        :type page_after: str
        :param page_last: For paginated responses, the last N services will be returned. Used in combination with <code>page[before]</code>.
        :type page_last: float
        :param page_before: Cursor before which elements will be returned as a page. The page size is provided by <code>page[last]</code>.
        :type page_before: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DeviceWarrantyReadMultiple
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the read_multiple_device_warranty_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.read_multiple_device_warranty_with_http_info(filter_covered_under_warranty, filter_covered_under_service, tenants, page_first, page_after, page_last, page_before, **kwargs)  # noqa: E501

    @validate_arguments
    def read_multiple_device_warranty_with_http_info(self, filter_covered_under_warranty : Annotated[Optional[StrictBool], Field(description="Filter by warranty coverage status.")] = None, filter_covered_under_service : Annotated[Optional[StrictBool], Field(description="Filter by service coverage status.")] = None, tenants : Annotated[Optional[StrictStr], Field(description="Comma delimited list of tenant IDs to request info from.")] = None, page_first : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="For paginated responses, the first N elements will be returned. Used in combination with <code>page[after]</code>.")] = None, page_after : Annotated[Optional[StrictStr], Field(description="Cursor after which elements will be returned as a page. The page size is provided by <code>page[first]</code>.")] = None, page_last : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="For paginated responses, the last N services will be returned. Used in combination with <code>page[before]</code>.")] = None, page_before : Annotated[Optional[StrictStr], Field(description="Cursor before which elements will be returned as a page. The page size is provided by <code>page[last]</code>.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Read Multiple Devices’ Warranty Info  # noqa: E501

        Use the Read Multiple Devices’ Warranty API to pull the collected warranty information about the various devices Auvik has discovered. You’ll need the client IDs for the clients you want to run the multiple read against.<br> <br> To find the client IDs, run the <a href=\"#operation/readMultipleTenants\">Read Multiple Tenants API.</a><br> <br> Looking at the detail screen on the right, click cURL to see the command that will be used. Click <b>Copy</b> to copy the details of the command to your clipboard. Be sure to edit the following parameters within the command: <ul>     <li>Within the API URL, <b>us1.my</b> (https://auvikapi.us1.my.auvik.com) should be updated to match the region in which your account resides. To locate the region, log into your Auvik dashboard and look at the URL in your browser’s address bar.</li>     <li><i>user@example.com</i> should be the email address of a user with permissions to view device information.</li>     <li><i>apiKey</i> should be the API key that’s been set for the user.</li>     <li><i>195798545063742726</i> should be the ID or comma delimited IDs of the client(s) whose data you wish to fetch information from. </li>     <li><i>filter[coveredUnderWarranty]=true</i> should be whichever key and value pair you want to filter the result set by. See below for a list of filterable parameters.</li> </ul>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.read_multiple_device_warranty_with_http_info(filter_covered_under_warranty, filter_covered_under_service, tenants, page_first, page_after, page_last, page_before, async_req=True)
        >>> result = thread.get()

        :param filter_covered_under_warranty: Filter by warranty coverage status.
        :type filter_covered_under_warranty: bool
        :param filter_covered_under_service: Filter by service coverage status.
        :type filter_covered_under_service: bool
        :param tenants: Comma delimited list of tenant IDs to request info from.
        :type tenants: str
        :param page_first: For paginated responses, the first N elements will be returned. Used in combination with <code>page[after]</code>.
        :type page_first: float
        :param page_after: Cursor after which elements will be returned as a page. The page size is provided by <code>page[first]</code>.
        :type page_after: str
        :param page_last: For paginated responses, the last N services will be returned. Used in combination with <code>page[before]</code>.
        :type page_last: float
        :param page_before: Cursor before which elements will be returned as a page. The page size is provided by <code>page[last]</code>.
        :type page_before: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DeviceWarrantyReadMultiple, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'filter_covered_under_warranty',
            'filter_covered_under_service',
            'tenants',
            'page_first',
            'page_after',
            'page_last',
            'page_before'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_multiple_device_warranty" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('filter_covered_under_warranty') is not None:  # noqa: E501
            _query_params.append(('filter[coveredUnderWarranty]', _params['filter_covered_under_warranty']))

        if _params.get('filter_covered_under_service') is not None:  # noqa: E501
            _query_params.append(('filter[coveredUnderService]', _params['filter_covered_under_service']))

        if _params.get('tenants') is not None:  # noqa: E501
            _query_params.append(('tenants', _params['tenants']))

        if _params.get('page_first') is not None:  # noqa: E501
            _query_params.append(('page[first]', _params['page_first']))

        if _params.get('page_after') is not None:  # noqa: E501
            _query_params.append(('page[after]', _params['page_after']))

        if _params.get('page_last') is not None:  # noqa: E501
            _query_params.append(('page[last]', _params['page_last']))

        if _params.get('page_before') is not None:  # noqa: E501
            _query_params.append(('page[before]', _params['page_before']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/vnd.api+json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['ApiKey']  # noqa: E501

        _response_types_map = {
            '200': "DeviceWarrantyReadMultiple",
            '400': "BasicError",
            '403': "BasicError",
            '404': "BasicError",
            '500': None,
        }

        return self.api_client.call_api(
            '/inventory/device/warranty', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def read_single_device_details(self, id : Annotated[StrictStr, Field(..., description="ID of device")], **kwargs) -> DeviceDetailsReadSingle:  # noqa: E501
        """Read a Single Device’s Details  # noqa: E501

        Use the Read Single Device’s Details API to pull extra collected information about a specific device Auvik has discovered not already included in the Device Info API. You’ll need the device ID for the specific device.<br> <br> To find the device IDs, run the <a href=\"#operation/readMultipleDeviceInfo\">Read Multiple Devices API</a>.<br> <br> Looking at the detail screen on the right, click cURL to see the command that will be used. Click <b>Copy</b> to copy the details of the command to your clipboard. Be sure to edit the following parameters within the command: <ul>     <li>Within the API URL, <b>us1.my</b> (https://auvikapi.us1.my.auvik.com) should be updated to match the region in which your account resides. To locate the region, log into your Auvik dashboard and look at the URL in your browser’s address bar.</li>     <li><i>user@example.com</i> should be the email address of a user with permissions to view device details.</li>     <li><i>apiKey</i> should be the API key that’s been set for the user.</li>     <li><i>MTk...2Nw</i> should be the device’s ID.</li> </ul>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.read_single_device_details(id, async_req=True)
        >>> result = thread.get()

        :param id: ID of device (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DeviceDetailsReadSingle
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the read_single_device_details_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.read_single_device_details_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def read_single_device_details_with_http_info(self, id : Annotated[StrictStr, Field(..., description="ID of device")], **kwargs) -> ApiResponse:  # noqa: E501
        """Read a Single Device’s Details  # noqa: E501

        Use the Read Single Device’s Details API to pull extra collected information about a specific device Auvik has discovered not already included in the Device Info API. You’ll need the device ID for the specific device.<br> <br> To find the device IDs, run the <a href=\"#operation/readMultipleDeviceInfo\">Read Multiple Devices API</a>.<br> <br> Looking at the detail screen on the right, click cURL to see the command that will be used. Click <b>Copy</b> to copy the details of the command to your clipboard. Be sure to edit the following parameters within the command: <ul>     <li>Within the API URL, <b>us1.my</b> (https://auvikapi.us1.my.auvik.com) should be updated to match the region in which your account resides. To locate the region, log into your Auvik dashboard and look at the URL in your browser’s address bar.</li>     <li><i>user@example.com</i> should be the email address of a user with permissions to view device details.</li>     <li><i>apiKey</i> should be the API key that’s been set for the user.</li>     <li><i>MTk...2Nw</i> should be the device’s ID.</li> </ul>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.read_single_device_details_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: ID of device (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DeviceDetailsReadSingle, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_single_device_details" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/vnd.api+json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['ApiKey']  # noqa: E501

        _response_types_map = {
            '200': "DeviceDetailsReadSingle",
            '400': "BasicError",
            '403': "BasicError",
            '404': "BasicError",
            '500': None,
        }

        return self.api_client.call_api(
            '/inventory/device/detail/{id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def read_single_device_extended_detail(self, id : Annotated[StrictStr, Field(..., description="ID of device")], **kwargs) -> DeviceDetailsExtendedReadSingle:  # noqa: E501
        """Read a Single Device’s Extended Details  # noqa: E501

        Use the Read Single Device’s Extended Details API to get a device’s extended details. Many device types have information collected and tracked by Auvik that are unique to that device type. Use this endpoint to access such information for a given device.<br> <br> To find the device IDs, run the <a href=\"#operation/readMultipleDeviceInfo\">Read Multiple Devices API</a>.<br> <br> Looking at the detail screen on the right, click cURL to see the command that will be used. Click <b>Copy</b> to copy the details of the command to your clipboard. Be sure to edit the following parameters within the command: <ul>     <li>Within the API URL, <b>us1.my</b> (https://auvikapi.us1.my.auvik.com) should be updated to match the region in which your account resides. To locate the region, log into your Auvik dashboard and look at the URL in your browser’s address bar.</li>     <li><i>user@example.com</i> should be the email address of a user with permissions to view device extended details.</li>     <li><i>apiKey</i> should be the API key that’s been set for the user.</li>     <li><i>MTk...2Nw</i> should be the device’s ID.</li> </ul>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.read_single_device_extended_detail(id, async_req=True)
        >>> result = thread.get()

        :param id: ID of device (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DeviceDetailsExtendedReadSingle
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the read_single_device_extended_detail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.read_single_device_extended_detail_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def read_single_device_extended_detail_with_http_info(self, id : Annotated[StrictStr, Field(..., description="ID of device")], **kwargs) -> ApiResponse:  # noqa: E501
        """Read a Single Device’s Extended Details  # noqa: E501

        Use the Read Single Device’s Extended Details API to get a device’s extended details. Many device types have information collected and tracked by Auvik that are unique to that device type. Use this endpoint to access such information for a given device.<br> <br> To find the device IDs, run the <a href=\"#operation/readMultipleDeviceInfo\">Read Multiple Devices API</a>.<br> <br> Looking at the detail screen on the right, click cURL to see the command that will be used. Click <b>Copy</b> to copy the details of the command to your clipboard. Be sure to edit the following parameters within the command: <ul>     <li>Within the API URL, <b>us1.my</b> (https://auvikapi.us1.my.auvik.com) should be updated to match the region in which your account resides. To locate the region, log into your Auvik dashboard and look at the URL in your browser’s address bar.</li>     <li><i>user@example.com</i> should be the email address of a user with permissions to view device extended details.</li>     <li><i>apiKey</i> should be the API key that’s been set for the user.</li>     <li><i>MTk...2Nw</i> should be the device’s ID.</li> </ul>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.read_single_device_extended_detail_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: ID of device (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DeviceDetailsExtendedReadSingle, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_single_device_extended_detail" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/vnd.api+json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['ApiKey']  # noqa: E501

        _response_types_map = {
            '200': "DeviceDetailsExtendedReadSingle",
            '400': "BasicError",
            '403': "BasicError",
            '404': "BasicError",
            '500': None,
        }

        return self.api_client.call_api(
            '/inventory/device/detail/extended/{id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def read_single_device_info(self, id : Annotated[StrictStr, Field(..., description="ID of device")], include : Annotated[Optional[StrictStr], Field(description="Use to include the full resource objects of the list device relationships.")] = None, fields_device_detail : Annotated[Optional[StrictStr], Field(description="Use to limit the attributes that will be returned in the included detail object to only what is specified by this query parameter. Requires <code>include=deviceDetail</code>")] = None, **kwargs) -> DeviceInfoReadSingle:  # noqa: E501
        """Read a Single Device’s Info  # noqa: E501

        Use the Read Single Device’s Info API to pull the collected information about a specific device Auvik has discovered. You’ll need the device ID for the specific device.<br> <br> To find the device IDs, run the <a href=\"#operation/readMultipleDeviceInfo\">Read Multiple Devices API</a>.<br> <br> Looking at the detail screen on the right, click cURL to see the command that will be used. Click <b>Copy</b> to copy the details of the command to your clipboard. Be sure to edit the following parameters within the command: <ul>     <li>Within the API URL, <b>us1.my</b> (https://auvikapi.us1.my.auvik.com) should be updated to match the region in which your account resides. To locate the region, log into your Auvik dashboard and look at the URL in your browser’s address bar.</li>     <li><i>user@example.com</i> should be the email address of a user with permissions to view device information.</li>     <li><i>apiKey</i> should be the API key that’s been set for the user.</li>     <li><i>MTk...2Nw</i> should be the device’s ID. </li></ul>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.read_single_device_info(id, include, fields_device_detail, async_req=True)
        >>> result = thread.get()

        :param id: ID of device (required)
        :type id: str
        :param include: Use to include the full resource objects of the list device relationships.
        :type include: str
        :param fields_device_detail: Use to limit the attributes that will be returned in the included detail object to only what is specified by this query parameter. Requires <code>include=deviceDetail</code>
        :type fields_device_detail: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DeviceInfoReadSingle
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the read_single_device_info_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.read_single_device_info_with_http_info(id, include, fields_device_detail, **kwargs)  # noqa: E501

    @validate_arguments
    def read_single_device_info_with_http_info(self, id : Annotated[StrictStr, Field(..., description="ID of device")], include : Annotated[Optional[StrictStr], Field(description="Use to include the full resource objects of the list device relationships.")] = None, fields_device_detail : Annotated[Optional[StrictStr], Field(description="Use to limit the attributes that will be returned in the included detail object to only what is specified by this query parameter. Requires <code>include=deviceDetail</code>")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Read a Single Device’s Info  # noqa: E501

        Use the Read Single Device’s Info API to pull the collected information about a specific device Auvik has discovered. You’ll need the device ID for the specific device.<br> <br> To find the device IDs, run the <a href=\"#operation/readMultipleDeviceInfo\">Read Multiple Devices API</a>.<br> <br> Looking at the detail screen on the right, click cURL to see the command that will be used. Click <b>Copy</b> to copy the details of the command to your clipboard. Be sure to edit the following parameters within the command: <ul>     <li>Within the API URL, <b>us1.my</b> (https://auvikapi.us1.my.auvik.com) should be updated to match the region in which your account resides. To locate the region, log into your Auvik dashboard and look at the URL in your browser’s address bar.</li>     <li><i>user@example.com</i> should be the email address of a user with permissions to view device information.</li>     <li><i>apiKey</i> should be the API key that’s been set for the user.</li>     <li><i>MTk...2Nw</i> should be the device’s ID. </li></ul>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.read_single_device_info_with_http_info(id, include, fields_device_detail, async_req=True)
        >>> result = thread.get()

        :param id: ID of device (required)
        :type id: str
        :param include: Use to include the full resource objects of the list device relationships.
        :type include: str
        :param fields_device_detail: Use to limit the attributes that will be returned in the included detail object to only what is specified by this query parameter. Requires <code>include=deviceDetail</code>
        :type fields_device_detail: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DeviceInfoReadSingle, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'include',
            'fields_device_detail'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_single_device_info" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        if _params.get('include') is not None:  # noqa: E501
            _query_params.append(('include', _params['include']))

        if _params.get('fields_device_detail') is not None:  # noqa: E501
            _query_params.append(('fields[deviceDetail]', _params['fields_device_detail']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/vnd.api+json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['ApiKey']  # noqa: E501

        _response_types_map = {
            '200': "DeviceInfoReadSingle",
            '400': "BasicError",
            '403': "BasicError",
            '404': "BasicError",
            '500': None,
        }

        return self.api_client.call_api(
            '/inventory/device/info/{id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def read_single_device_lifecycle(self, id : Annotated[StrictStr, Field(..., description="ID of device")], **kwargs) -> DeviceLifecycleReadSingle:  # noqa: E501
        """Read a Single Device’s Lifecycle Info  # noqa: E501

        Use the Read Single Device’s Lifecycle Info API to pull the collected information about a specific device Auvik has discovered. You’ll need the device ID for the specific device.<br> <br> To find the device IDs, run the <a href=\"#operation/readMultipleDeviceInfo\">Read Multiple Devices API</a>.<br> <br> Looking at the detail screen on the right, click cURL to see the command that will be used. Click <b>Copy</b> to copy the details of the command to your clipboard. Be sure to edit the following parameters within the command: <ul>     <li>Within the API URL, <b>us1.my</b> (https://auvikapi.us1.my.auvik.com) should be updated to match the region in which your account resides. To locate the region, log into your Auvik dashboard and look at the URL in your browser’s address bar.</li>     <li><i>user@example.com</i> should be the email address of a user with permissions to view device information.</li>     <li><i>apiKey</i> should be the API key that’s been set for the user.</li>     <li><i>MTk...2Nw</i> should be the device’s ID. </li></ul>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.read_single_device_lifecycle(id, async_req=True)
        >>> result = thread.get()

        :param id: ID of device (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DeviceLifecycleReadSingle
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the read_single_device_lifecycle_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.read_single_device_lifecycle_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def read_single_device_lifecycle_with_http_info(self, id : Annotated[StrictStr, Field(..., description="ID of device")], **kwargs) -> ApiResponse:  # noqa: E501
        """Read a Single Device’s Lifecycle Info  # noqa: E501

        Use the Read Single Device’s Lifecycle Info API to pull the collected information about a specific device Auvik has discovered. You’ll need the device ID for the specific device.<br> <br> To find the device IDs, run the <a href=\"#operation/readMultipleDeviceInfo\">Read Multiple Devices API</a>.<br> <br> Looking at the detail screen on the right, click cURL to see the command that will be used. Click <b>Copy</b> to copy the details of the command to your clipboard. Be sure to edit the following parameters within the command: <ul>     <li>Within the API URL, <b>us1.my</b> (https://auvikapi.us1.my.auvik.com) should be updated to match the region in which your account resides. To locate the region, log into your Auvik dashboard and look at the URL in your browser’s address bar.</li>     <li><i>user@example.com</i> should be the email address of a user with permissions to view device information.</li>     <li><i>apiKey</i> should be the API key that’s been set for the user.</li>     <li><i>MTk...2Nw</i> should be the device’s ID. </li></ul>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.read_single_device_lifecycle_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: ID of device (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DeviceLifecycleReadSingle, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_single_device_lifecycle" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/vnd.api+json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['ApiKey']  # noqa: E501

        _response_types_map = {
            '200': "DeviceLifecycleReadSingle",
            '400': "BasicError",
            '403': "BasicError",
            '404': "BasicError",
            '500': None,
        }

        return self.api_client.call_api(
            '/inventory/device/lifecycle/{id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def read_single_device_warranty(self, id : Annotated[StrictStr, Field(..., description="ID of device")], **kwargs) -> DeviceWarrantyReadSingle:  # noqa: E501
        """Read a Single Device’s Warranty Info  # noqa: E501

        Use the Read Single Device’s Warranty Info API to pull the collected information about a specific device Auvik has discovered. You’ll need the device ID for the specific device.<br> <br> To find the device IDs, run the <a href=\"#operation/readMultipleDeviceInfo\">Read Multiple Devices API</a>.<br> <br> Looking at the detail screen on the right, click cURL to see the command that will be used. Click <b>Copy</b> to copy the details of the command to your clipboard. Be sure to edit the following parameters within the command: <ul>     <li>Within the API URL, <b>us1.my</b> (https://auvikapi.us1.my.auvik.com) should be updated to match the region in which your account resides. To locate the region, log into your Auvik dashboard and look at the URL in your browser’s address bar.</li>     <li><i>user@example.com</i> should be the email address of a user with permissions to view device information.</li>     <li><i>apiKey</i> should be the API key that’s been set for the user.</li>     <li><i>MTk...2Nw</i> should be the device’s ID. </li></ul>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.read_single_device_warranty(id, async_req=True)
        >>> result = thread.get()

        :param id: ID of device (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DeviceWarrantyReadSingle
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the read_single_device_warranty_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.read_single_device_warranty_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def read_single_device_warranty_with_http_info(self, id : Annotated[StrictStr, Field(..., description="ID of device")], **kwargs) -> ApiResponse:  # noqa: E501
        """Read a Single Device’s Warranty Info  # noqa: E501

        Use the Read Single Device’s Warranty Info API to pull the collected information about a specific device Auvik has discovered. You’ll need the device ID for the specific device.<br> <br> To find the device IDs, run the <a href=\"#operation/readMultipleDeviceInfo\">Read Multiple Devices API</a>.<br> <br> Looking at the detail screen on the right, click cURL to see the command that will be used. Click <b>Copy</b> to copy the details of the command to your clipboard. Be sure to edit the following parameters within the command: <ul>     <li>Within the API URL, <b>us1.my</b> (https://auvikapi.us1.my.auvik.com) should be updated to match the region in which your account resides. To locate the region, log into your Auvik dashboard and look at the URL in your browser’s address bar.</li>     <li><i>user@example.com</i> should be the email address of a user with permissions to view device information.</li>     <li><i>apiKey</i> should be the API key that’s been set for the user.</li>     <li><i>MTk...2Nw</i> should be the device’s ID. </li></ul>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.read_single_device_warranty_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: ID of device (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DeviceWarrantyReadSingle, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_single_device_warranty" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/vnd.api+json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['ApiKey']  # noqa: E501

        _response_types_map = {
            '200': "DeviceWarrantyReadSingle",
            '400': "BasicError",
            '403': "BasicError",
            '404': "BasicError",
            '500': None,
        }

        return self.api_client.call_api(
            '/inventory/device/warranty/{id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
